---
layout: post
title : Kotlin - 05. Part2. 람다로 프로그래밍
date  : 2022-01-17
image : kotlin-logo-05.png
tags  : kotlin lambda lambdaprogramming lambdaexpression
---

## Kotlin 의 람다 `Lambda`

- [Part.1 람다 식](/2022/01/17/Kotlin-05-1/)
- [Part.1 멤버 참조](/2022/01/17/Kotlin-05-1/)
- [Part.1 함수형 스타일](/2022/01/17/Kotlin-05-1/)
- [Part.2 시퀀스 `Sequence` : 지연 컬렉션 연산](/2022/01/17/Kotlin-05-2/)
- [Part.2 자바 함수형 인터페이스 코틀린에서 사용](/2022/01/17/Kotlin-05-2/)
- [Part.2 수신 객체 지정 람다 사용](/2022/01/17/Kotlin-05-2/)

---

## 지연 계산(`lazy`) 컬렉션 연산
### 코틀린의 'Sequence'

코틀린의 함수형 API들은 연산 과정에서 생성되는 새로운 중간 컬렉션을 *즉시* 생성한다. 그런 경우 중간 결과 객체가 많아지면서 메모리 이슈가 발생하고 성능 저하와 같은 장애가 발생할 수 있다. 코틀린에서는 이런 장애를 방지하기 위해 컬렉션 연산을 **지연 계산**할 수 있는 **시퀀스 `sequence` API**를 제공한다.

먼저 왜 중간 결과 객체가 장애를 발생할 수 있는지 살펴보겠다.

{% highlight kotlin %}
// `people` 컬렉션의 `Person` 클래스의 `name` 중 "A" 로 시작하는 원소 찾는다.
people
    .map(Person::name)
    .filter { it.startWith("A") }
{% endhighlight %}

위 코드의 문제점은 `people` 리스트의 모든 원소를 `.map()` 반복하면서 **새로운 `String` 객체를 리스트의 사이즈만큼 다시 생성한다.**

이런 코드는 수백만 개의 리스트 컬렉션을 처리할 때 문제가 발생할 수 있다. 그렇다면, 시퀀스 `sequence` 는 어떤 처리를 하는 것일까?

{% highlight kotlin %}
people
    .asSequence()
    .map(Person::name)
    .filter { it.startWith("A") }
{% endhighlight %}

시퀀스 API 는 일반 컬렉션의 함수형 API를 그대로 구현하고 똑같이 활용 가능하지만, 큰 차이점은 바로 **중간 결과 객체를 생성하지 않는다.**

과연 "중간 결과 객체를 생성하지 않는다." 라는 의미는 무엇일까?

### 시퀀스 연산 실행: 중간 연산과 최종 연산

---

#### 출처
- [Kotlin in Action](https://www.manning.com/books/kotlin-in-action)
- [oyunseong.log - Kotlin Lambda Expression, 코틀린 람다 표현식](https://velog.io/@oyunseong/Kotlin-Lambda-Expression-%EC%BD%94%ED%8B%80%EB%A6%B0-%EB%9E%8C%EB%8B%A4-%ED%91%9C%ED%98%84%EC%8B%9D)
