---
layout: post
title : Kotlin - 03. 함수 정의와 호출
date  : 2021-12-28
image : kotlin-extensions.jpeg
tags  : kotlin extensions extensionfunction 확장함수
---

# Kotlin 공부하기 - 03. 함수 정의와 호출

## Kotlin 함수

`Kotlin` 의 함수 관련된 다양한 `API` 를 살펴보고자 한다.  실제 꽤 많은 내용을 포함하고 있다.

- 컬렉션 `Collection` 만들기
- 함수 호출
  - 이름 붙인 인자
  - `Default` 파라미터 값
  - 최상위 함수와 최상위 프로퍼티 `const`
- 확장 `extensions` 함수 & 프로퍼티
- 컬렉션 처리 : 가변 길이 인자, 중위 함수 호출
- 문자열과 정규식
- 로컬 함수와 확장

---

### Collection 만들기

`Kotlin` 에서는 `Java` 와 달리 `Collection` 생성을 손쉬운 방식으로 제공하고 있다.

```kotlin
// List 생성
val list = listOf(1, 2, 3)

// Map 생성
val map = mapOf("1" to "One", "2" to "Two", "3" to "Three")

// 위와 같은 방식 외에도 다양한 함수를 통해 `Collection` 생성이 가능하다.
```

----

### 함수 호출

함수를 호출하는 방식을 단순히 파라미터만 넘기는 `Java` 와 달리 개발자가 코딩 상에 실수는 줄이기 위한 다양한 방식을 제공해주는 `Kotlin` 이다.

#### 이름 붙인 인자

```Kotlin
fun <T> joinToString(
	collection: Collection<T>,
    separator: String,
    prefix: String,
    postfix: String
) {
    // collection 의 정보를 문자열로 결합하는 함수
}
```

위와 같은 `joinToString` 함수를 호출한다고 하였을 때, 일반적으로는 `joinToString(list, ",", "[",  "]")` 처럼 지정된 매개 변수 순서대로 값을 채워줘야했다. 이런 코딩은 함수의 매개 변수 순서를 확인하고 맞게 제대로 넘겨주는지 확인해야하며, 이런 과정에서 실수가 발생될 수 있는 여지가 있다.

그래서 `Kotlin` 에서는 코딩상 오류 범하기 쉬운 이 함수 호출 방식에 **이름을 붙인 인자** 방식을 활용하였다.

```kotlin
fun main() {
    val list = listOf(1, 2, 3)
    val str = joinToString(
    	collection = list,
        separator = ", ",
        prefix = "[",
        postfix = "]"
    )
    println(str)	// [1, 2, 3]
}
```

> `Java` 에서는 `Builder Pattern` 방식으로 이런 부분을 보완해주고 있고, IDE 기능을 통해 충분히 보완이 가능하다.

#### `Default` 파라미터 값

함수의 매개 변수의 기본 `Default` 값 설정을 이용하여 굳이 인자를 넣어주지 않더라도 함수 호출이 가능하다.

이런 부분은 무자비하게 늘어나는 오버로딩 `overloading` 메소드를 방지할 수 있다.

```kotlin
fun <T> joinToString(
	collection: Collection<T>,
    separator: String = ", ",
    prefix: String = "[",
    postfix: String = "]"
) {
    // collection 의 정보를 문자열로 결합하는 함수
}

fun main() {
    val list = ...
	println(joinToString(list)) 				// [1, 2, 3]
    println(joinToString(list, " | "))			// [1 | 2 | 3]
    println(joinToString(list, ", ", "", ""))	// 1, 2, 3
}
```

> `Java` 는 `@JvmOverloads` 라는 어노테이션을 함수에 추가하면, 매개 변수별로 오버로딩 함수를 자동 생성해준다.

#### 최상위 함수와 프로퍼티

실제 `Java` 프로그램을 개발하면서 정적 `static` 인 클래스나 함수를 생성하여 유틸리티 클래스로 많이 활용한다.

이런 유틸리티 클래스를 `Kotlin` 에서는 무의미한 클래스로 판단하고, 유틸리티 함수를 별로 클래스 아래 포함시키지 않기 위해 최상위 함수 사용을 지원한다.

##### 최상위 함수

```kotlin
// 파일명 : Join.kt
package strings

fun joinToString(...) : String { ... }
```

`Join.kt` 라는 파일 안에는 `joinToString` 함수만 포함하고 있고, 클래스는 존재하지 않는다. `Kotlin` 은 이런 형식을 함수도 컴파일 에러는 발생하지 않는다.

위 파일이 `Java` 로 변환되면 아래와 같다.

```java
package strings;

public class JoinKt {
    public static String joinToString(...) { ... }
}
```

최상위 함수를 통해 무의미한 클래스를 호출하는 부분을 줄일 수 있게 되면서 가독성을 높일 수 있는 부분이 있지만, 한편으로는 코드 분석이 어려워질 수도 있겠다라는 생각이 든다.

> 최상위 함수가 포함된 클래스명을 바꾸거나 지정하고 싶다면, `@JvmName` 어노테이션을 활용하면 가능하다.

##### 최상위 프로퍼티

개발 도중 정적인 상수를 사용하고 싶은 경우, 간편하게 변경자 하나로 생성 가능하다.

```kotlin
const val ZERO = 0
```

`const` 변경자로 선언된 변수는 최상위 함수처럼 클래스안에 있지 않아도 정적인 최상위 프로퍼티로 선언이 된다.

`const` 변경자는 `public static final` 로 변경된다.

---

### 확장 `extensions` 함수 & 프로퍼티

확장 함수 & 프로퍼티의 개념은 `Kotlin` 에서 `Java` 의 자연스럽게 통합하고 운용할 수 있는 핵심 목표를 충족시켜주는 역할을 하였다. `Java`에서 제공하는 `API`를 `Kotlin`으로 직접 변환하지 않고도 사용할 수 있게 하고, 재작성하지 않고도 `Kotlin` 에서 제공하는 여러 편리한 기능을 사용하기 위해 확장 함수가 나왔다고 한다.

>`Kotlin`의 확장 함수는 어떻게 `Java` 의 `API`를 통합하다는 걸까?
>
>```kotlin
>val list = listOf(1, 2, 3)
>
>println(list.last())	// 3
>println(list.max())		// 3
>```
>
>위 코드는 `Java`의 `Collection` 객체에서 `Kotlin`의 추가된 함수를 활요한 예제이다.
>
>어떻게 기존 `Java`의 `Collection` 객체의 함수를 추가할 수 있었을까? 바로 **확장 함수** 때문이다.



#### 확장 함수

확장 함수는 아래와 같은 기본 형식을 가지고 있다.

`fun [수신 객체 타입].함수명() { this // 수신 객체 }`

확장 함수가 호출되는 대상이 되는 값(객체)을 **수신 객체 (`this`)** 라고 부르며, 생략도 가능하다.

```kotlin
package strings

fun String.lastChar() : Char = this.get(this.length - 1)

// this 생략
fun String.lastChar() : Char = get(length - 1)
```

> `Java`에서 `Kotlin`의 확장 함수 사용하기
>
> ```java
> char c = StringUtilKt.lastChar("Java");
> ```

##### 확장 함수 주의할 점

- 확장 함수도 일반적인 클래스의 변수와 메소드를 사용할 수 있지만, 캡슐화를 깰 수는 없다. 그 의미는 클래스 내부에서만 사용 가능한 `private` 나 `protected` 멤버 변수나 함수는 사용할 수 없음을 뜻한다.

- 확장 함수를 선언하였더라도, 모든 클래스에서 바로 사용하는 것이 아니라 `import` 헤야만 사용 가능하다.

- 동일한 확장 함수명을 다른 파일에서 생성하게 되면 충돌이 발생할 수 있다. 하지만, 별도 `import` 를 받아서 사용한다면 가능하다.
- 확장 함수는 오버라이드가 불가하다.

#### 확장 프로퍼티

확장 프로퍼티는 이름과 다르게 실제로는 아무 상태(값)도 저장할 수 없다. 하지만 확장 프로퍼티를 활용하여 좀 더 간결한 코드를 작성 가능하다.

```kotlin
val String.lastChar: Char
	get() = get(length - 1)

println("Kotlin".lastChar)		// n
```

위 코드처럼 `String` 객체의 확장 프로퍼티 `lastChar`를 생성하였다. 하지만 확장 프로퍼티에는 상태를 저장할 수 있는 뒷받침하는 필드 `backing field` 가 없기 때문에, `getter` 접근자 메소드가 필요하고, 필요한 경우`setter` 를 통해서 **변경 가능한 확장 프로퍼티**도 생성 가능하다.

```kotlin
var StringBuilder.lastChar: Char
	get() = get(length - 1)
	set(value: Char) {
        this.setCharAt(length - 1, value)
    }

val sb = StringBuilder("Hello Kotlin?")
sb.lastChar = '!'
println(sb)			// Hello Kotlin!
```

---

### 컬렉션 처리 : 가변 길이 인자, 중위 함수 호출

#### 가변 길이 인자 `vararg`

`listOf()` 와 같은 함수의 매개 변수를 가변 길이의 인자로 받는다. `Java` 에서는 타입 뒤에  `...` 활용하여 가변 길이 인자를 받았지만, `Kotlin` 에서는 `vararg` 변경자를 활용하면 된다.

```kotlin
fun listOf<T>(vararg values: T): List<T> { ... }
```

#### 중위 함수 호출

처음 `Kotlin` 으로 개발할 때, `map` 객체를 선언하다보면 의아한 문법이 보이게 된다. 바로 `mapOf()` 함수이다.

```kotlin
val map = mapOf(1 to "One", 2 to "Two", 3 to "Three")
```

`mapOf`에서 `to` 는 `Kotlin`의 키워드가 아니라 **일반 메소드**이다. 이 코드는 **중위 함수**이라는 특별한 방식으로 일반 메소드를 호출하는 코드이다.

`1 to "One"` 은 `1.to("One")` 과 동일하다.

중위 함수는 일반 메소드도 가능하지만, 확장 함수도 가능하며, `infix` 라는 변경자를 이용하여 선언 가능하다. 다음은 `to()` 메소드의 구현체이다.

```kotlin
infix fun Any.to(other: Any) = Pair(this, other)
```

> 구조 분해
