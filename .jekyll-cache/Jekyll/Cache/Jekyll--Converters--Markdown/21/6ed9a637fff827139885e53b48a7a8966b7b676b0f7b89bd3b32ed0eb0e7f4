I"*<h2 id="redis-와-cache">Redis 와 Cache</h2>
<p>Redis (<strong>Remote Dictionary Server</strong>)는 메모리 기반의 다양한 구조 데이터를 메모리에 저장이 가능하여 높은, Read, Write 성능을 보장하는 비 관계형 데이터베이스이다. 그리하여 <strong>Caching Solution</strong> 으로 많이 사용중인데,
그렇다면 <strong>Caching Solution</strong> 는 왜 필요할까?</p>

<hr />

<h3 id="cache">Cache</h3>
<p><strong>Cache</strong> 는 여러가지의 의미와 정의가 있지만, 요청에 대한 응답을 빠르게 서비스하기 위해 미리 저장해두는 저장소라고 정리하고 싶다. 같은 요청과 응답에 대해 DB 접근 없이 메모리 접근만으로도 빠르게 응답 처리할 수 있을 것이다.
이러한 <em>Caching</em> 을 다양한 자료 구조 형태로 관리를 해주는 것이 <strong>Redis</strong> 이다.</p>

<hr />

<h3 id="redis-의-특징">Redis 의 특징</h3>
<ul>
  <li>영속성을 지원하는 <strong>In-Memory</strong> 데이터 저장소이다.</li>
  <li>메모리에 데이터를 저장하기 때문에 처리 속도가 빠르다.</li>
  <li>디스크에도 저장되기 때문에 데이터 복구가 가능하다.<strong>(<code class="language-plaintext highlighter-rouge">Memcached</code> 와 차이점)</strong></li>
  <li>만료일을 지정하는 방식으로 데이터 삭제가 가능하다.</li>
  <li>저장소의 메모리 재사용하지 않는다.</li>
  <li>다양한 데이터 타입을 지원한다.
    <ul>
      <li><strong>Redis 가 지원하는 데이터 타입</strong>
        <ol>
          <li>Strings : 단순한 key - value 구조</li>
          <li>Sets : 중복이 없는 순서가 없는 Strings 데이터 구조</li>
          <li>Sorted Sets : Sets 구조의 순서를 보장하는 구조</li>
          <li>Hashs : key - value 의 다중 구조 Object 를 저장할 수 있는 데이터 구조</li>
          <li>Lists : Array 형태의 데이터 구조</li>
        </ol>
      </li>
    </ul>
  </li>
  <li>Master - Slave 구조의 Server 복제를 지원한다.
    <ul>
      <li><em>version 5.0.0 부터는 slave 용어보단 secondary 로 변경</em></li>
    </ul>
  </li>
  <li>Write 성능을 위해 Client 에 <strong>Sharding</strong> 을 지원한다.
    <ul>
      <li><strong>Sharding</strong> ? 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 방법</li>
    </ul>
  </li>
</ul>

<h4 id="redis-의-장점">Redis 의 장점</h4>
<ul>
  <li>다양한 구조의 데이터 처리 가능</li>
  <li>List 형 데이터의 입력과 삭제의 성능은 MySQL에 비해 10배 정도 빠른 성능 차이를 발휘</li>
  <li>메모리를 활용하면서 영속적인 데이터 보존 가능
    <ul>
      <li><em>삭제, expries</em> 설정이 아니라면 데이터가 삭제되지 않음</li>
      <li><em>스냅샷</em> 기능을 제공하여 메모리의 내용을 별도 파일로 저장가능하여 복구 기능 제공</li>
    </ul>
  </li>
  <li><strong>1개의 Single Thread 로 수행</strong>되기 때문에, 서버 하나에 여러개의 서버 운용이 가능하다.</li>
</ul>

<hr />

<h3 id="redis-caching-전략">Redis Caching 전략</h3>
<h4 id="look-aside-cache">Look aside cache</h4>
<p>일반적인 Caching 처리 전략</p>
<ol>
  <li>Client 으로부터 요청을 받아, <strong>먼저 Cache 에서 데이터가 있는지 확인한다.</strong></li>
  <li>Cache 에 요청에 대한 데이터가 있는 경우 해당 데이터를 응답해준다.</li>
  <li>Cache 에 데이터가 없는 경우, DB 조회 후 응답 처리한다.</li>
</ol>

<h4 id="write-back">Write back</h4>
<p>데이터를 일단 Cache 에 모두 저장하고, 특정 시점마다 한번씩 DB 에 <code class="language-plaintext highlighter-rouge">insert</code> 하는 전략</p>
<ul>
  <li>ex) 500건 데이터를 추가할 때,
    <ul>
      <li><code class="language-plaintext highlighter-rouge">insert</code>를 500건씩 하는 것보단, 500건을 모아서 한번에 <code class="language-plaintext highlighter-rouge">insert</code> 하는 것이 빠르다.</li>
    </ul>
  </li>
</ul>

<p>하지만, 메모리 공간에 데이터 저장은 유실이 될 가능성이 높기 때문에, 재생 가능한 데이터 혹은 <code class="language-plaintext highlighter-rouge">insert</code> 하기 heavy 한 데이터를 추가할 때 유용한 전략</p>

<hr />

<h3 id="redis-관리">Redis 관리</h3>
<h4 id="redis-key">Redis Key</h4>
<ul>
  <li>Redis 의 <code class="language-plaintext highlighter-rouge">Key</code> 는 문자열이기 때문에 모든 이진 시퀀스를 키로 사용 가능하고, 빈 문자열까지도 <code class="language-plaintext highlighter-rouge">Key</code> 가 될 수 있다. 최대 <code class="language-plaintext highlighter-rouge">Key</code> 크기는 512MB 이다.</li>
  <li>Redis 의 <code class="language-plaintext highlighter-rouge">Key</code> 설계는 매우 중요하며, 설계에 따라 Redis 의 성능 차이가 발생할 수 있다.</li>
</ul>

<h4 id="expire-set-기능">Expire Set 기능</h4>
<ul>
  <li>적절한 만료일을 지정해야 메모리 부하 조절이 가능하다.</li>
</ul>

<h4 id="maxmemory-policy">Maxmemory policy</h4>
<p><strong>Redis</strong> 의 memory 도 한계가 있기 때문에 서비스 운영할 때, 모니터링과 관리는 필요하다. 만약 memory 의 한계에 도달하여 서비스의 지연을 방지하기 위해 <strong>Redis</strong> 의 <strong><em>maxmemory policy</em></strong> 를 적절하게 이용하여 메모리 확보를 하는 것이 중요하다.</p>

<ul>
  <li>noeviction : 기존의 데이터를 그대로 유지하는 정책. 결국 OOM(Out Of Memory) 오류를 반환하고 새로운 데이터를 삭제</li>
  <li>allkeys-lru : LRU(Least Recently Used) 페이지 교체 알고리을 통해 데이터를 삭제하여 메모리르 확보</li>
  <li>volatile-lur : Expire Set 을 가진 데이터 중 LRU 에 의해 삭제하여 메모리 확보</li>
  <li>allkeys-random : Random 으로 데이터를 삭제하여 메모리 확보</li>
  <li>volatile-random : Expire Set 을 가진 데이터 중 Random 으로 데이터를 삭제하여 메모리 확보</li>
  <li>volatile-ttl : Expire Set 을 가진 데이터 중 TTL(Time To Live) 값이 제일 작은 데이터 순으로 삭</li>
  <li>allkeys-lfu : 가장 적게 access 된 데이터부터 삭제하여 메모리 확보</li>
  <li>volatile-lfu : Expire Set 을 가진 데이터 중 가장 적게 access 된 데이터부터 삭제</li>
</ul>

<hr />

<h3 id="redis-replication">Redis Replication</h3>
<p><strong>Redis</strong> 의 Read 분산과 데이터 이중화를 위한 <strong><em>Master - Slave</em></strong> 구조를 사용할 수 있다. <strong>Master</strong> 에서 <em>Read/Write</em> 모두 수행하지만, <strong>Slave</strong> 는 <em>Read</em> 만 가능하다. 그래서 <strong>Slave</strong> 에도 같은 데이터가 존재해야하기 때문에 <strong><em>Redis Replication</em></strong> 이 발생하게 된다.</p>

<h4 id="redis의-replication-과정">Redis의 Replication 과정</h4>
<ol>
  <li>먼저 <strong>Slave</strong> 설정에서 <code class="language-plaintext highlighter-rouge">replcaof &lt;master ip&gt; &lt;master port&gt;</code> 을 통해 <strong>Master</strong> 에 데이터 sync 를 요청한다.</li>
  <li><strong>Master</strong> 에서 <code class="language-plaintext highlighter-rouge">.rdb</code> 파일을 생성하기 위해 <code class="language-plaintext highlighter-rouge">fork</code> 를 통해 메모리를 복사하여 디스크에 저장한다. 이 과정에서 들어오는 데이터는 모두 <em>Buffer</em> 에 저장한다.</li>
  <li><strong>Master</strong> 에서 생성된 <code class="language-plaintext highlighter-rouge">.rdb</code> 파일을 <strong>Slave</strong> 에 전달하고 디스크에 저장한 후 메모리에 로드한다.</li>
  <li><strong>Master</strong> 의 <em>Buffer</em> 모아둔 데이터는 다시 <strong>Slave</strong> 로 전달한다.</li>
</ol>

<p><strong>Replication</strong> 시 주의할 점은, 위 과정에서 <strong>Master</strong> 에서 메모리 데이터를 복제하기 위해서는 그만큼의 동일한 크기 메모리 저장이 필요하다.</p>

<p>또한, 만약에 <strong>Master</strong> 가 장애가 발생하게 되면, Client 를 <strong>Slave</strong> 를 통한 <em>Read</em> 만 가능하다. 그래서 <strong>Slave</strong> 를 승격시켜줘야한다. 이러한 <em>failover</em> 를 대비한 Redis 만의 방식이 있다.</p>

<hr />

<h3 id="redis-failover-처리-방식">Redis Failover 처리 방식</h3>
<h4 id="redis-cluster-기반-failover">Redis Cluster 기반 Failover</h4>
<p><strong><em>Redist Cluster</em></strong> 는 Redis 의 여러 노드들이 각자 <em>Hash 기반의 Slot</em> 를 가지고 있기 때문에, 여러개의 <strong>Master - Slave</strong> 구조를 구성할 수 있다. 이런 구조는 <strong>Master 1</strong> 장애를 <strong>Slave 1</strong> 이 책임질 수 있는 구조를 만들 수 있다.</p>

<h4 id="coordinator-기반-failover">Coordinator 기반 Failover</h4>
<p><code class="language-plaintext highlighter-rouge">zookeeper</code>, <code class="language-plaintext highlighter-rouge">etcd</code>, <code class="language-plaintext highlighter-rouge">consul</code> 등의 <strong>Coordinator</strong> 를 활용한 <em>failover</em> 방식이다.
Health Checker 를 통해 각 Redis 의 상태를 감지하고, 장애가 발생한다면 다른 Redis 를 <strong>Master</strong> 로 승격하는 방식이다.</p>

<h4 id="vip-or-dns-기반-failover">VIP or DNS 기반 Failover</h4>
<p>Redis 서버마다 <code class="language-plaintext highlighter-rouge">Virtual IP</code> 를 설정하고 Health Checker 가 Redis 상태 변경할 때마다 <code class="language-plaintext highlighter-rouge">VIP</code> 변경하여 장애에 대응한다.
<em>(DNS 방식은 DNS 를 변경해주는 차이점이 있다.)</em></p>

<hr />

<p><strong>Redis 관련 다른 Post</strong></p>
<ul>
  <li><a href="/2021/02/21/AWS_ElastiCache/">AWS ElastiCache For Redis + Spring Boot 연동</a></li>
</ul>

<p><strong>Reference</strong></p>
<ul>
  <li><a href="https://daddyprogrammer.org/post/3870/spring-rest-api-redis-caching/">daddyprogrammer 블로그 [Redis로 api 결과 캐싱(Caching) 처리]</a></li>
  <li><a href="https://medium.com/@jyejye9201/%EB%A0%88%EB%94%94%EC%8A%A4-redis-%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-2b7af75fa818">Alic Medium [레디스(Redis)란 무엇인가?]</a></li>
  <li><a href="https://medium.com/garimoo/%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%A0%88%EB%94%94%EC%8A%A4-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC-01-92aaa24ca8cc">garimoo Medium [Redis 튜토리얼]</a></li>
</ul>
:ET