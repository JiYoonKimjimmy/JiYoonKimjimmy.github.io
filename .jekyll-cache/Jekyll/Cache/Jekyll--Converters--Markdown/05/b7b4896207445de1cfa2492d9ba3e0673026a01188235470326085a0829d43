I"+<h2 id="객체-지향-5대-원칙">객체 지향 5대 원칙</h2>

<h3 id="객체-지향-프로그래밍의-5대-원칙">객체 지향 프로그래밍의 5대 원칙?</h3>
<ul>
  <li>SRP(단일 책임 원칙)</li>
  <li>OCP(개방-폐쇄 원칙)</li>
  <li>LSP(리스코프 치환 원칙)</li>
  <li>DIP(의존성 역전 원칙)</li>
  <li>ISP(인터페이스 분리 원칙)</li>
</ul>

<h3 id="1-single-responsibility-principlesrp-단일-책임-원칙">1. Single Responsibility Principle(SRP, 단일 책임 원칙)</h3>
<p><strong>새로운 요구사항 반영과 프로그램 수정의 영향이 적으려면? 프로그램의 책임이 단 하나인 경우이다.</strong>
<strong><em>(프로그램의 책임은 ‘기능’으로 정의 가능하다.)</em></strong></p>

<p>프로그램이 가지고 있는 책임이 많다면 함수의 결합도가 높을 가능성이 있기 때문이다. 강한 경합도는 수정에 대한 <code class="language-plaintext highlighter-rouge">side-effect</code> 발생도가 높아지게 된다.</p>

<h3 id="2-open-closed-principleocp-개방-폐쇄-원칙">2. Open-Closed Principle(OCP, 개방-폐쇄 원칙)</h3>
<p><strong><em>기존 코드 변경 없이(Closed) 신규 기능 추가 및 수정할 수 있는(Open) 프로그램 설계가 필요하다</em></strong></p>

<p>변경 없이 새로운 기능을 추가하거나 수정하는 작업은 자주 변경되는 기능은 수정하기 쉽게 설계하고, 변경되지 않는 기능은 영향을 받지 않게 하는 것이다.
<code class="language-plaintext highlighter-rouge">Java</code> 에서는 <code class="language-plaintext highlighter-rouge">Interface</code> 를 통해서 <code class="language-plaintext highlighter-rouge">OCP</code> 원칙을 적용할 수 있을 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// OCP example-1</span>
<span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">pay</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"pay by card"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
      <span class="n">order</span><span class="o">.</span><span class="na">pay</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">OCP example-1</code> 는 주문<code class="language-plaintext highlighter-rouge">Order</code>에 대한 결제 방식<code class="language-plaintext highlighter-rouge">pay()</code>을 정의하고 있다.
하지만, 주문의 결제 방식이 달라진다고 하면, <code class="language-plaintext highlighter-rouge">Order</code>클래스의 <code class="language-plaintext highlighter-rouge">pay</code>함수를 수정해야할 것이다. <strong>이는 <code class="language-plaintext highlighter-rouge">OCP</code> 원칙에 위배된다.</strong></p>

<p><code class="language-plaintext highlighter-rouge">OCP</code> 원칙을 만족하기 위해선, <code class="language-plaintext highlighter-rouge">pay</code>함수를 쉽게 변경할 수 있게 <code class="language-plaintext highlighter-rouge">Interface</code>로 분리시킬 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// OCP example-2</span>
<span class="kd">interface</span> <span class="nc">PayOrder</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pay</span><span class="o">();</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Card</span> <span class="kd">implements</span> <span class="nc">PayOrder</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pay</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"pay by card"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">class</span> <span class="nc">Cash</span> <span class="kd">implements</span> <span class="nc">PayOrder</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pay</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="s">"pay by cash"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// OCP example-3</span>
<span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">PayOrder</span> <span class="n">type</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setType</span><span class="o">(</span><span class="nc">PayOrder</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">type</span> <span class="o">=</span> <span class="n">type</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">pay</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">type</span><span class="o">.</span><span class="na">pay</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Client</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">();</span>
      <span class="n">order</span><span class="o">.</span><span class="na">setType</span><span class="o">(</span><span class="k">new</span> <span class="nc">Card</span><span class="o">());</span>
      <span class="n">order</span><span class="o">.</span><span class="na">pay</span><span class="o">();</span>    <span class="c1">// log : "pay by card"</span>

      <span class="n">order</span><span class="o">.</span><span class="na">setType</span><span class="o">(</span><span class="k">new</span> <span class="nc">Cash</span><span class="o">());</span>
      <span class="n">order</span><span class="o">.</span><span class="na">pay</span><span class="o">();</span>    <span class="c1">// log : "pay by cash"</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">OCP example-2</code>에서 <code class="language-plaintext highlighter-rouge">PayOrder</code> 인터페이스를 통해서 각 결제 수단 클래스의 <code class="language-plaintext highlighter-rouge">pay</code>함수를 재정의하도록 설계하였고,
<code class="language-plaintext highlighter-rouge">OCP example-3</code>에서 <code class="language-plaintext highlighter-rouge">Order</code>클래스의 <code class="language-plaintext highlighter-rouge">type</code>을 통해 결제 수단 객체를 지정하여 각 <code class="language-plaintext highlighter-rouge">pay</code> 함수를 호출하였을 때, 영향이 받지 않도록 하였다.
이와 같은 설계는 <strong>Strategy Pattern(전략 패턴)</strong> 이라는 디자인 패턴으로도 정의할 수 있다.</p>

<h3 id="3-liskov-substitution-principlelsp-리스코프-치환-원칙">3. Liskov Substitution Principle(LSP, 리스코프 치환 원칙)</h3>
<p><strong>자식 클래스는 부모 클래스가 가진 기능을 수행할 수 있어야 한다.</strong></p>

<p>부모 클래스와 자식 클래스 사이의 기능은 일관성이 있어야 하며, 부모 클래스의 객체 대신 자식 클래스의 객체를 사용해도 문제가 없어야 한다. 상속 관계에서는 일반화 관계(IS-A)가 성립해야 하고, 일반화 관계는 일관성이 있다는 것이다.</p>

<h3 id="4-dependency-inversion-principledip-의존-역전-원칙">4. Dependency Inversion Principle(DIP, 의존 역전 원칙)</h3>
<p><strong>변화하기 쉬운 것보다 변화하기 어려운 것에 의존해야 한다는 원칙이다.</strong></p>

<p>객체 지향 관점에서 구체화 된 클래스는 변화하기 쉽고, 인터페이스나 추상클래스가 변화하기 어려운 클래스가 된다. <code class="language-plaintext highlighter-rouge">DIP</code> 원칙을 만족하고자 한다면, 구체적인 클래스보다 인터페이스나 추상클래스와 관계를 맺어야 한다는 것을 의미한다.</p>

<h3 id="5-interface-segregation-principleisp-인터페이스-분리-원칙">5. Interface Segregation Principle(ISP, 인터페이스 분리 원칙)</h3>
<p><strong>하나의 클래스 안에 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.</strong></p>

<p>자신이 사용하지 않는 기능의 인터페이스에는 영향을 받지 않아야 한다는 의미로, 스마트폰의 전화 기능은 통화를 할 때 사진 촬영을 필수로 하지 않는 것처럼 전화, 사진 촬영 등 다양한 기능을 독립적인 인터페이스로 구현하여, 서로에게 영향을 받지 않도록 설계해야 한다.
<code class="language-plaintext highlighter-rouge">ISP</code> 원칙에 적합한 시스템은 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 보다 쉽게 수행할 수 있게 된다.</p>

<hr />

<blockquote>
  <p>출처 - <a href="https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99">SOLID 원칙 - Programming Note</a></p>
</blockquote>
:ET